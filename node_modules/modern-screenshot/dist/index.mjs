var De = Object.defineProperty, Re = Object.defineProperties;
var Fe = Object.getOwnPropertyDescriptors;
var P = Object.getOwnPropertySymbols;
var J = Object.prototype.hasOwnProperty, K = Object.prototype.propertyIsEnumerable;
var Q = Math.pow, Y = (e, t, n) => t in e ? De(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, v = (e, t) => {
  for (var n in t || (t = {}))
    J.call(t, n) && Y(e, n, t[n]);
  if (P)
    for (var n of P(t))
      K.call(t, n) && Y(e, n, t[n]);
  return e;
}, R = (e, t) => Re(e, Fe(t));
var Z = (e, t) => {
  var n = {};
  for (var r in e)
    J.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && P)
    for (var r of P(e))
      t.indexOf(r) < 0 && K.call(e, r) && (n[r] = e[r]);
  return n;
};
var b = (e, t, n) => new Promise((r, a) => {
  var i = (s) => {
    try {
      c(n.next(s));
    } catch (l) {
      a(l);
    }
  }, o = (s) => {
    try {
      c(n.throw(s));
    } catch (l) {
      a(l);
    }
  }, c = (s) => s.done ? r(s.value) : Promise.resolve(s.value).then(i, o);
  c((n = n.apply(e, t)).next());
});
function se(e, t) {
  return e[13] = 1, e[14] = t >> 8, e[15] = t & 255, e[16] = t >> 8, e[17] = t & 255, e;
}
const ie = "p".charCodeAt(0), ce = "H".charCodeAt(0), le = "Y".charCodeAt(0), ue = "s".charCodeAt(0);
let q;
function _e() {
  const e = new Int32Array(256);
  for (let t = 0; t < 256; t++) {
    let n = t;
    for (let r = 0; r < 8; r++)
      n = n & 1 ? 3988292384 ^ n >>> 1 : n >>> 1;
    e[t] = n;
  }
  return e;
}
function Ue(e) {
  let t = -1;
  q || (q = _e());
  for (let n = 0; n < e.length; n++)
    t = q[(t ^ e[n]) & 255] ^ t >>> 8;
  return t ^ -1;
}
function Pe(e) {
  const t = e.length - 1;
  for (let n = t; n >= 4; n--)
    if (e[n - 4] === 9 && e[n - 3] === ie && e[n - 2] === ce && e[n - 1] === le && e[n] === ue)
      return n - 3;
  return 0;
}
function fe(e, t, n = !1) {
  const r = new Uint8Array(13);
  t *= 39.3701, r[0] = ie, r[1] = ce, r[2] = le, r[3] = ue, r[4] = t >>> 24, r[5] = t >>> 16, r[6] = t >>> 8, r[7] = t & 255, r[8] = r[4], r[9] = r[5], r[10] = r[6], r[11] = r[7], r[12] = 1;
  const a = Ue(r), i = new Uint8Array(4);
  if (i[0] = a >>> 24, i[1] = a >>> 16, i[2] = a >>> 8, i[3] = a & 255, n) {
    const o = Pe(e);
    return e.set(r, o), e.set(i, o + 13), e;
  } else {
    const o = new Uint8Array(4);
    o[0] = 0, o[1] = 0, o[2] = 0, o[3] = 9;
    const c = new Uint8Array(54);
    return c.set(e, 0), c.set(o, 33), c.set(r, 37), c.set(i, 50), c;
  }
}
const $e = "AAlwSFlz", Be = "AAAJcEhZ", Le = "AAAACXBI";
function Me(e) {
  let t = e.indexOf($e);
  return t === -1 && (t = e.indexOf(Be)), t === -1 && (t = e.indexOf(Le)), t;
}
const V = "[modern-screenshot]", N = typeof window != "undefined", Oe = N && "Worker" in window, de = N && "atob" in window, We = N && "btoa" in window;
var ae;
const H = N ? (ae = window.navigator) == null ? void 0 : ae.userAgent : "", ge = H.includes("Chrome"), $ = H.includes("AppleWebKit") && !ge, me = H.includes("Firefox"), qe = (e) => e && "__CONTEXT__" in e, je = (e) => e.constructor.name === "CSSFontFaceRule", Ve = (e) => e.constructor.name === "CSSImportRule", T = (e) => e.nodeType === 1, I = (e) => typeof e.className == "object", He = (e) => I(e) && e.tagName === "svg", he = (e) => I(e) && e.tagName === "image", z = (e) => T(e) && typeof e.style != "undefined" && !I(e), ze = (e) => e.nodeType === 8, Xe = (e) => e.nodeType === 3, F = (e) => e.tagName === "IMG", L = (e) => e.tagName === "VIDEO", Ge = (e) => e.tagName === "CANVAS", ee = (e) => e.tagName === "TEXTAREA", Ye = (e) => e.tagName === "INPUT", Je = (e) => e.tagName === "STYLE", Ke = (e) => e.tagName === "SCRIPT", Qe = (e) => e.tagName === "SELECT", Ze = (e) => e.tagName === "SLOT", et = (e) => e.tagName === "IFRAME", E = (...e) => console.warn(V, ...e), tt = (e) => console.time(`${V} ${e}`), nt = (e) => console.timeEnd(`${V} ${e}`), rt = (e) => {
  var n;
  const t = (n = e == null ? void 0 : e.createElement) == null ? void 0 : n.call(e, "canvas");
  return t && (t.height = t.width = 1), t && "toDataURL" in t && Boolean(t.toDataURL("image/webp").includes("image/webp"));
}, j = (e) => e.startsWith("data:");
function we(e, t) {
  if (e.match(/^[a-z]+:\/\//i))
    return e;
  if (N && e.match(/^\/\//))
    return window.location.protocol + e;
  if (e.match(/^[a-z]+:/i) || !N)
    return e;
  const n = M().implementation.createHTMLDocument(), r = n.createElement("base"), a = n.createElement("a");
  return n.head.appendChild(r), n.body.appendChild(a), t && (r.href = t), a.href = e, a.href;
}
function M(e) {
  var t;
  return (t = e && T(e) ? e == null ? void 0 : e.ownerDocument : e) != null ? t : window.document;
}
const O = "http://www.w3.org/2000/svg";
function pe(e, t, n) {
  const r = M(n).createElementNS(O, "svg");
  return r.setAttributeNS(null, "width", e.toString()), r.setAttributeNS(null, "height", t.toString()), r.setAttributeNS(null, "viewBox", `0 0 ${e} ${t}`), r;
}
function ye(e) {
  const t = new XMLSerializer().serializeToString(e).replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F\uD800-\uDFFF\uFFFE\uFFFF]/ug, "");
  return `data:image/svg+xml;charset=utf-8,${encodeURIComponent(t)}`;
}
function ot(e, t = "image/png", n = 1) {
  return b(this, null, function* () {
    try {
      return yield new Promise((r, a) => {
        e.toBlob((i) => {
          i ? r(i) : a(new Error("Blob is null"));
        }, t, n);
      });
    } catch (r) {
      if (de)
        return E("Failed canvas to blob", { type: t, quality: n }, r), at(e.toDataURL(t, n));
      throw r;
    }
  });
}
function at(e) {
  var c, s;
  const [t, n] = e.split(","), r = (s = (c = t.match(/data:(.+);/)) == null ? void 0 : c[1]) != null ? s : void 0, a = window.atob(n), i = a.length, o = new Uint8Array(i);
  for (let l = 0; l < i; l += 1)
    o[l] = a.charCodeAt(l);
  return new Blob([o], { type: r });
}
function be(e, t) {
  return new Promise((n, r) => {
    const a = new FileReader();
    a.onload = () => n(a.result), a.onerror = () => r(a.error), a.onabort = () => r(new Error(`Failed read blob to ${t}`)), t === "dataUrl" ? a.readAsDataURL(e) : t === "arrayBuffer" && a.readAsArrayBuffer(e);
  });
}
const st = (e) => be(e, "dataUrl"), it = (e) => be(e, "arrayBuffer");
function x(e, t) {
  const n = M(t).createElement("img");
  return n.decoding = "sync", n.loading = "eager", n.src = e, n;
}
function _(e, t) {
  return new Promise((n) => {
    const { timeout: r, ownerDocument: a, onError: i } = t != null ? t : {}, o = typeof e == "string" ? x(e, M(a)) : e;
    let c = null, s = null;
    function l() {
      n(o), c && clearTimeout(c), s == null || s();
    }
    if (r && (c = setTimeout(l, r)), L(o)) {
      const u = o.currentSrc || o.src;
      if (!u)
        return o.poster ? _(o.poster, t).then(n) : l();
      if (o.readyState >= 2)
        return l();
      const f = l, d = (g) => {
        E(
          "Failed video load",
          u,
          g
        ), i == null || i(g), l();
      };
      s = () => {
        o.removeEventListener("loadeddata", f), o.removeEventListener("error", d);
      }, o.addEventListener("loadeddata", f, { once: !0 }), o.addEventListener("error", d, { once: !0 });
    } else {
      const u = he(o) ? o.href.baseVal : o.currentSrc || o.src;
      if (!u)
        return l();
      const f = () => b(this, null, function* () {
        if (F(o) && "decode" in o)
          try {
            yield o.decode();
          } catch (g) {
            E(
              "Failed to decode image, trying to render anyway",
              o.dataset.originalSrc || u,
              g
            );
          }
        l();
      }), d = (g) => {
        E(
          "Failed image load",
          o.dataset.originalSrc || u,
          g
        ), l();
      };
      if (F(o) && o.complete)
        return f();
      s = () => {
        o.removeEventListener("load", f), o.removeEventListener("error", d);
      }, o.addEventListener("load", f, { once: !0 }), o.addEventListener("error", d, { once: !0 });
    }
  });
}
function ct(e, t) {
  return b(this, null, function* () {
    z(e) && (F(e) || L(e) ? yield _(e, { timeout: t }) : yield Promise.all(
      ["img", "video"].flatMap((n) => Array.from(e.querySelectorAll(n)).map((r) => _(r, { timeout: t })))
    ));
  });
}
const Se = function() {
  let t = 0;
  const n = () => (
    // eslint-disable-next-line no-bitwise
    `0000${(Math.random() * Q(36, 4) << 0).toString(36)}`.slice(-4)
  );
  return () => (t += 1, `u${n()}${t}`);
}();
function Ee(e) {
  return e == null ? void 0 : e.split(",").map((t) => t.trim().replace(/"|'/g, "").toLowerCase()).filter(Boolean);
}
function lt(e) {
  return {
    time: (t) => e && tt(t),
    timeEnd: (t) => e && nt(t),
    warn: (...t) => e && E(...t)
  };
}
function ut(e) {
  return {
    cache: e ? "no-cache" : "force-cache"
  };
}
function A(e, t) {
  return b(this, null, function* () {
    return qe(e) ? e : ft(e, R(v({}, t), { autoDestruct: !0 }));
  });
}
function ft(e, t) {
  return b(this, null, function* () {
    var d, g, h, p;
    const { scale: n = 1, workerUrl: r, workerNumber: a = 1 } = t || {}, i = Boolean(t == null ? void 0 : t.debug), o = (d = e.ownerDocument) != null ? d : N ? window.document : void 0, c = (h = (g = e.ownerDocument) == null ? void 0 : g.defaultView) != null ? h : N ? window : void 0, s = /* @__PURE__ */ new Map(), l = R(v({
      // Options
      width: 0,
      height: 0,
      quality: 1,
      type: "image/png",
      scale: n,
      backgroundColor: null,
      style: null,
      filter: null,
      maximumCanvasSize: 0,
      timeout: 3e4,
      progress: null,
      debug: i,
      fetch: v({
        requestInit: ut((p = t == null ? void 0 : t.fetch) == null ? void 0 : p.bypassingCache),
        placeholderImage: "data:image/png;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        bypassingCache: !1
      }, t == null ? void 0 : t.fetch),
      font: {},
      drawImageInterval: 100,
      workerUrl: null,
      workerNumber: a,
      onCloneNode: null,
      onEmbedNode: null,
      onCreateForeignObjectSvg: null,
      autoDestruct: !1
    }, t), {
      // InternalContext
      __CONTEXT__: !0,
      log: lt(i),
      node: e,
      ownerDocument: o,
      ownerWindow: c,
      dpi: n === 1 ? null : 96 * n,
      svgStyleElement: Ce(o),
      svgDefsElement: o == null ? void 0 : o.createElementNS(O, "defs"),
      svgStyles: /* @__PURE__ */ new Map(),
      defaultComputedStyles: /* @__PURE__ */ new Map(),
      workers: [
        ...new Array(
          Oe && r && a ? a : 0
        )
      ].map(() => {
        try {
          const y = new Worker(r);
          return y.onmessage = (m) => b(this, null, function* () {
            var C, k, D, G;
            const { url: S, result: w } = m.data;
            w ? (k = (C = s.get(S)) == null ? void 0 : C.resovle) == null || k.call(C, w) : (G = (D = s.get(S)) == null ? void 0 : D.reject) == null || G.call(D, new Error(`Error receiving message from worker: ${S}`));
          }), y.onmessageerror = (m) => {
            var w, C;
            const { url: S } = m.data;
            (C = (w = s.get(S)) == null ? void 0 : w.reject) == null || C.call(w, new Error(`Error receiving message from worker: ${S}`));
          }, y;
        } catch (y) {
          return E("Failed to new Worker", y), null;
        }
      }).filter(Boolean),
      fontFamilies: /* @__PURE__ */ new Set(),
      fontCssTexts: /* @__PURE__ */ new Map(),
      acceptOfImage: `${[
        rt(o) && "image/webp",
        "image/svg+xml",
        "image/*",
        "*/*"
      ].filter(Boolean).join(",")};q=0.8`,
      requests: s,
      drawImageCount: 0,
      tasks: []
    });
    l.log.time("wait until load"), yield ct(e, l.timeout), l.log.timeEnd("wait until load");
    const { width: u, height: f } = dt(e, l);
    return l.width = u, l.height = f, l;
  });
}
function Ce(e) {
  if (!e)
    return;
  const t = e.createElement("style"), n = t.ownerDocument.createTextNode(`
.______background-clip--text {
  background-clip: text;
  -webkit-background-clip: text;
}
`);
  return t.appendChild(n), t;
}
function dt(e, t) {
  let { width: n, height: r } = t;
  if (T(e) && (!n || !r)) {
    const a = e.getBoundingClientRect();
    n = n || a.width || Number(e.getAttribute("width")) || 0, r = r || a.height || Number(e.getAttribute("height")) || 0;
  }
  return { width: n, height: r };
}
function gt(e, t) {
  return b(this, null, function* () {
    const {
      log: n,
      timeout: r,
      drawImageCount: a,
      drawImageInterval: i
    } = t;
    n.time("image to canvas");
    const o = yield _(e, { timeout: r }), { canvas: c, context2d: s } = mt(e.ownerDocument, t), l = () => {
      try {
        s == null || s.drawImage(o, 0, 0, c.width, c.height);
      } catch (u) {
        E("Failed to drawImage", u);
      }
    };
    l();
    for (let u = 0; u < a; u++)
      yield new Promise((f) => {
        setTimeout(() => {
          l(), f();
        }, u + i);
      });
    return t.drawImageCount = 0, n.timeEnd("image to canvas"), c;
  });
}
function mt(e, t) {
  const { width: n, height: r, scale: a, backgroundColor: i, maximumCanvasSize: o } = t, c = e.createElement("canvas");
  c.width = Math.floor(n * a), c.height = Math.floor(r * a), c.style.width = `${n}px`, c.style.height = `${r}px`, o && (c.width > o || c.height > o) && (c.width > o && c.height > o ? c.width > c.height ? (c.height *= o / c.width, c.width = o) : (c.width *= o / c.height, c.height = o) : c.width > o ? (c.height *= o / c.width, c.width = o) : (c.width *= o / c.height, c.height = o));
  const s = c.getContext("2d");
  return s && i && (s.fillStyle = i, s.fillRect(0, 0, c.width, c.height)), { canvas: c, context2d: s };
}
const ht = [
  "width",
  "height"
], wt = [
  "stroke",
  "fill"
];
function ve(e, t, n) {
  var y;
  const { defaultComputedStyles: r, ownerDocument: a } = n, i = e.nodeName.toLowerCase(), o = I(e) && i !== "svg", c = o ? wt.map((m) => [m, e.getAttribute(m)]).filter(([, m]) => m !== null) : [], s = [
    o && "svg",
    i,
    c.map((m, S) => `${m}=${S}`).join(","),
    t
  ].filter(Boolean).join(":");
  if (r.has(s))
    return r.get(s);
  let l = n.sandbox;
  if (!l)
    try {
      a && (l = a.createElement("iframe"), l.id = `__SANDBOX__-${Se()}`, l.width = "0", l.height = "0", l.style.visibility = "hidden", l.style.position = "fixed", a.body.appendChild(l), (y = l.contentWindow) == null || y.document.write('<!DOCTYPE html><meta charset="UTF-8"><title></title><body>'), n.sandbox = l);
    } catch (m) {
      E("Failed to create iframe sandbox", m);
    }
  if (!l)
    return /* @__PURE__ */ new Map();
  const u = l.contentWindow;
  if (!u)
    return /* @__PURE__ */ new Map();
  const f = u.document;
  let d, g;
  o ? (d = f.createElementNS(O, "svg"), g = d.ownerDocument.createElementNS(d.namespaceURI, i), c.forEach(([m, S]) => {
    g.setAttributeNS(null, m, S);
  }), d.appendChild(g)) : d = g = f.createElement(i), g.textContent = " ", f.body.appendChild(d);
  const h = u.getComputedStyle(g, t), p = /* @__PURE__ */ new Map();
  for (let m = h.length, S = 0; S < m; S++) {
    const w = h.item(S);
    ht.includes(w) || p.set(w, h.getPropertyValue(w));
  }
  return f.body.removeChild(d), r.set(s, p), p;
}
function Te(e, t) {
  var i;
  const n = /* @__PURE__ */ new Map(), r = [], a = /* @__PURE__ */ new Map();
  for (let o = e.length, c = 0; c < o; c++) {
    const s = e.item(c), l = e.getPropertyValue(s), u = e.getPropertyPriority(s), f = s.lastIndexOf("-"), d = f > -1 ? s.substring(0, f) : void 0;
    if (d) {
      let g = a.get(d);
      g || (g = /* @__PURE__ */ new Map(), a.set(d, g)), g.set(s, [l, u]);
    }
    t.get(s) === l && !u || (d ? r.push(d) : n.set(s, [l, u]));
  }
  for (let o = r.length, c = 0; c < o; c++)
    (i = a.get(r[c])) == null || i.forEach((s, l) => n.set(l, s));
  return n;
}
const pt = [
  ":before",
  ":after"
  // ':placeholder', TODO
], yt = [
  ":-webkit-scrollbar",
  ":-webkit-scrollbar-button",
  // ':-webkit-scrollbar:horizontal', TODO
  ":-webkit-scrollbar-thumb",
  ":-webkit-scrollbar-track",
  ":-webkit-scrollbar-track-piece",
  // ':-webkit-scrollbar:vertical', TODO
  ":-webkit-scrollbar-corner",
  ":-webkit-resizer"
];
function bt(e, t, n, r) {
  const { ownerWindow: a, svgStyleElement: i, svgStyles: o } = r;
  if (!i || !a)
    return;
  function c(s) {
    var m;
    const l = a.getComputedStyle(e, s);
    let u = l.getPropertyValue("content");
    if (!u || u === "none")
      return;
    u = u.replace(/(')|(")|(counter\(.+\))/g, "");
    const f = [Se()], d = ve(e, s, r), g = [
      `content: '${u}';`
    ], h = Te(l, d);
    if (h.delete("content"), h.delete("-webkit-locale"), ((m = h.get("background-clip")) == null ? void 0 : m[0]) === "text" && t.classList.add("______background-clip--text"), h.forEach(([S, w], C) => {
      g.push(`${C}: ${S}${w ? " !important" : ""};`);
    }), g.length === 1)
      return;
    try {
      t.className = [t.className, ...f].join(" ");
    } catch (S) {
      return;
    }
    const p = g.join(`
  `);
    let y = o.get(p);
    y || (y = [], o.set(p, y)), y.push(`.${f[0]}:${s}`);
  }
  pt.forEach(c), n && yt.forEach(c);
}
function St(e, t) {
  ee(e) && (t.innerHTML = e.value), (ee(e) || Ye(e) || Qe(e)) && t.setAttribute("value", e.value);
}
function Et(e, t, n, r) {
  var l, u, f, d;
  const { ownerWindow: a } = r, i = t.style, o = a.getComputedStyle(e), c = ve(e, null, r), s = Te(o, c);
  return s.delete("transition-property"), s.delete("all"), s.delete("d"), s.delete("content"), n && (s.delete("margin-top"), s.delete("margin-right"), s.delete("margin-bottom"), s.delete("margin-left"), s.delete("margin-block-start"), s.delete("margin-block-end"), s.delete("margin-inline-start"), s.delete("margin-inline-end"), s.set("box-sizing", ["border-box", ""])), ((l = s.get("background-clip")) == null ? void 0 : l[0]) === "text" && t.classList.add("______background-clip--text"), ge && (s.has("font-kerning") || s.set("font-kerning", ["normal", ""]), (((u = s.get("overflow-x")) == null ? void 0 : u[0]) === "hidden" || ((f = s.get("overflow-y")) == null ? void 0 : f[0]) === "hidden") && ((d = s.get("text-overflow")) == null ? void 0 : d[0]) === "ellipsis" && e.scrollWidth === e.clientWidth && s.set("text-overflow", ["clip", ""])), s.forEach(([g, h], p) => {
    i.setProperty(p, g, h);
  }), s;
}
function Ct(e, t) {
  return b(this, null, function* () {
    var i, o, c;
    const { ownerDocument: n, svgDefsElement: r } = t, a = (o = (i = e.querySelectorAll) == null ? void 0 : i.call(e, "use")) != null ? o : [];
    if (a.length)
      for (let s = a.length, l = 0; l < s; l++) {
        const u = a[l], f = (c = u.getAttribute("xlink:href")) != null ? c : u.getAttribute("href");
        if (!f)
          continue;
        const d = n == null ? void 0 : n.querySelector(`svg ${f}`);
        !d || r != null && r.querySelector(f) || r == null || r.appendChild(yield W(d, t));
      }
    return e.cloneNode(!1);
  });
}
function vt(e, t) {
  var n;
  try {
    if ((n = e == null ? void 0 : e.contentDocument) != null && n.body)
      return W(e.contentDocument.body, t);
  } catch (r) {
    E("Failed to clone iframe", r);
  }
  return e.cloneNode(!1);
}
function Ae(e) {
  if (e.ownerDocument)
    try {
      const a = e.toDataURL();
      if (a !== "data:,")
        return x(a, e.ownerDocument);
    } catch (a) {
    }
  const t = e.cloneNode(!1), n = e.getContext("2d"), r = t.getContext("2d");
  try {
    return n && r && r.putImageData(
      n.getImageData(0, 0, e.width, e.height),
      0,
      0
    ), t;
  } catch (a) {
    E("Failed to clone canvas", a);
  }
  return t;
}
function Tt(e) {
  return b(this, null, function* () {
    if (e.ownerDocument && !e.currentSrc && e.poster)
      return x(e.poster, e.ownerDocument);
    const t = e.cloneNode(!1);
    t.crossOrigin = "anonymous", e.currentSrc && e.currentSrc !== e.src && (t.src = e.currentSrc);
    const n = t.ownerDocument;
    if (n) {
      let r = !0;
      if (yield _(t, {
        onError: () => r = !1
      }), !r)
        return e.poster ? x(e.poster, e.ownerDocument) : t;
      t.currentTime = e.currentTime, yield new Promise((i) => {
        t.addEventListener("seeked", i, { once: !0 });
      });
      const a = n.createElement("canvas");
      a.width = e.offsetWidth, a.height = e.offsetHeight;
      try {
        const i = a.getContext("2d");
        i && i.drawImage(t, 0, 0, a.width, a.height);
      } catch (i) {
        return E("Failed to clone video", i), e.poster ? x(e.poster, e.ownerDocument) : t;
      }
      return Ae(a);
    }
    return t;
  });
}
function At(e) {
  const t = e.cloneNode(!1);
  return e.currentSrc && e.currentSrc !== e.src && (t.src = e.currentSrc, t.srcset = ""), t.loading === "lazy" && (t.loading = "eager"), t;
}
function Nt(e, t) {
  return Ge(e) ? Ae(e) : et(e) ? vt(e, t) : F(e) ? At(e) : L(e) ? Tt(e) : He(e) ? Ct(e, t) : e.cloneNode(!1);
}
function te(e, t, n) {
  return b(this, null, function* () {
    T(t) && (Je(t) || Ke(t)) || n.filter && !n.filter(t) || e.appendChild(yield W(t, n));
  });
}
function ne(e, t, n) {
  return b(this, null, function* () {
    var a, i;
    const r = (i = T(e) ? (a = e.shadowRoot) == null ? void 0 : a.firstChild : void 0) != null ? i : e.firstChild;
    for (let o = r; o; o = o.nextSibling)
      if (!ze(o))
        if (T(o) && Ze(o) && typeof o.assignedNodes == "function") {
          const c = o.assignedNodes();
          for (let s = 0; s < c.length; s++)
            yield te(t, c[s], n);
        } else
          yield te(t, o, n);
  });
}
function xt(e, t) {
  const { backgroundColor: n, width: r, height: a, style: i } = t, o = e.style;
  if (n && o.setProperty("background-color", n, "important"), r && o.setProperty("width", `${r}px`, "important"), a && o.setProperty("height", `${a}px`, "important"), i)
    for (const c in i)
      o[c] = i[c];
}
function W(e, t, n = !1) {
  return b(this, null, function* () {
    var c, s, l, u;
    const { ownerDocument: r, ownerWindow: a, fontFamilies: i } = t;
    if (r && Xe(e))
      return r.createTextNode(e.data);
    if (r && a && T(e) && (z(e) || I(e))) {
      const f = yield Nt(e, t);
      f.removeAttribute('"');
      const d = Et(e, f, n, t);
      n && xt(f, t);
      const g = [
        (c = d.get("overflow-x")) == null ? void 0 : c[0],
        (s = d.get("overflow-y")) == null ? void 0 : s[1]
      ];
      return bt(
        e,
        f,
        // copy scrollbar
        g.includes("scroll") || (g.includes("auto") || g.includes("overlay")) && (e.scrollHeight > e.clientHeight || e.scrollWidth > e.clientWidth),
        t
      ), St(e, f), (u = Ee((l = d.get("font-family")) == null ? void 0 : l[0])) == null || u.forEach((h) => i.add(h)), L(e) || (yield ne(e, f, t)), f;
    }
    const o = e.cloneNode(!1);
    return yield ne(e, o, t), o;
  });
}
function It(e) {
  if (e.ownerDocument = void 0, e.ownerWindow = void 0, e.svgStyleElement = void 0, e.svgDefsElement = void 0, e.svgStyles.clear(), e.defaultComputedStyles.clear(), e.sandbox) {
    try {
      e.sandbox.remove();
    } catch (t) {
    }
    e.sandbox = void 0;
  }
  e.workers = [], e.fontFamilies.clear(), e.fontCssTexts.clear(), e.requests.clear(), e.tasks = [];
}
function kt(e) {
  const c = e, { url: t, timeout: n, responseType: r } = c, a = Z(c, ["url", "timeout", "responseType"]), i = new AbortController(), o = n ? setTimeout(() => i.abort(), n) : void 0;
  return fetch(t, v({ signal: i.signal }, a)).then((s) => {
    if (!s.ok)
      throw new Error("Failed fetch, not 2xx response", { cause: s });
    switch (r) {
      case "dataUrl":
        return s.blob().then(st);
      case "text":
      default:
        return s.text();
    }
  }).finally(() => clearTimeout(o));
}
function B(e, t) {
  const { url: n, requestType: r = "text", responseType: a = "text", imageDom: i } = t;
  let o = n;
  const {
    timeout: c,
    acceptOfImage: s,
    requests: l,
    fetch: {
      requestInit: u,
      bypassingCache: f,
      placeholderImage: d
    },
    workers: g
  } = e;
  let h;
  if (l.has(n))
    h = l.get(n);
  else {
    f && (o += (/\?/.test(o) ? "&" : "?") + new Date().getTime()), r === "image" && $ && e.drawImageCount++;
    const p = v({
      url: o,
      timeout: c,
      responseType: a,
      headers: r === "image" ? { accept: s } : void 0
    }, u);
    h = {
      type: r,
      resovle: void 0,
      reject: void 0,
      response: null
    }, h.response = (!$ && n.startsWith("http") && g.length ? new Promise((y, m) => {
      g[l.size & g.length - 1].postMessage(v({ rawUrl: n }, p)), h.resovle = y, h.reject = m;
    }) : kt(p)).catch((y) => {
      if (l.delete(n), r === "image" && d)
        return E("Failed to fetch image base64, trying to use placeholder image", o), typeof d == "string" ? d : d(i);
      throw y;
    }), l.set(n, h);
  }
  return h.response;
}
function Ne(e, t, n, r) {
  return b(this, null, function* () {
    if (!xe(e))
      return e;
    for (const [a, i] of Dt(e, t))
      try {
        const o = yield B(
          n,
          {
            url: i,
            requestType: r ? "image" : "text",
            responseType: "dataUrl"
          }
        );
        e = e.replace(Rt(a), `$1${o}$3`);
      } catch (o) {
        E("Failed to fetch css data url", a, o);
      }
    return e;
  });
}
function xe(e) {
  return /url\((['"]?)([^'"]+?)\1\)/.test(e);
}
const Ie = /url\((['"]?)([^'"]+?)\1\)/g;
function Dt(e, t) {
  const n = [];
  return e.replace(Ie, (r, a, i) => (n.push([i, we(i, t)]), r)), n.filter(([r]) => !j(r));
}
function Rt(e) {
  const t = e.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
  return new RegExp(`(url\\(['"]?)(${t})(['"]?\\))`, "g");
}
function Ft(e, t) {
  return b(this, null, function* () {
    const {
      ownerDocument: n,
      svgStyleElement: r,
      fontFamilies: a,
      fontCssTexts: i,
      tasks: o,
      font: c
    } = t;
    if (!(!n || !r || !a.size))
      if (c && c.cssText) {
        const s = oe(c.cssText, t);
        r.appendChild(n.createTextNode(`${s}
`));
      } else {
        const s = Array.from(n.styleSheets).filter((u) => {
          try {
            return "cssRules" in u && Boolean(u.cssRules.length);
          } catch (f) {
            return E(`Error while reading CSS rules from ${u.href}`, f), !1;
          }
        });
        yield Promise.all(
          s.flatMap((u) => Array.from(u.cssRules).map((f, d) => b(this, null, function* () {
            if (Ve(f)) {
              let g = d + 1;
              const h = f.href;
              let p = "";
              try {
                p = yield B(t, {
                  url: h,
                  requestType: "text",
                  responseType: "text"
                });
              } catch (m) {
                E(`Error fetch remote css import from ${h}`, m);
              }
              const y = p.replace(
                Ie,
                (m, S, w) => m.replace(w, we(w, h))
              );
              for (const m of Ut(y))
                try {
                  u.insertRule(
                    m,
                    m.startsWith("@import") ? g += 1 : u.cssRules.length
                  );
                } catch (S) {
                  E("Error inserting rule from remote css import", { rule: m, error: S });
                }
            }
          })))
        ), s.flatMap((u) => Array.from(u.cssRules)).filter((u) => {
          var f;
          return je(u) && xe(u.style.getPropertyValue("src")) && ((f = Ee(u.style.getPropertyValue("font-family"))) == null ? void 0 : f.some((d) => a.has(d)));
        }).forEach((u) => {
          const f = u, d = i.get(f.cssText);
          d ? r.appendChild(n.createTextNode(`${d}
`)) : o.push(
            Ne(
              f.cssText,
              f.parentStyleSheet ? f.parentStyleSheet.href : null,
              t
            ).then((g) => {
              g = oe(g, t), i.set(f.cssText, g), r.appendChild(n.createTextNode(`${g}
`));
            })
          );
        });
      }
  });
}
const _t = /(\/\*[\s\S]*?\*\/)/gi, re = /((@.*?keyframes [\s\S]*?){([\s\S]*?}\s*?)})/gi;
function Ut(e) {
  if (e == null)
    return [];
  const t = [];
  let n = e.replace(_t, "");
  for (; ; ) {
    const i = re.exec(n);
    if (!i)
      break;
    t.push(i[0]);
  }
  n = n.replace(re, "");
  const r = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi, a = new RegExp(
    "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})",
    "gi"
  );
  for (; ; ) {
    let i = r.exec(n);
    if (i)
      a.lastIndex = r.lastIndex;
    else if (i = a.exec(n), i)
      r.lastIndex = a.lastIndex;
    else
      break;
    t.push(i[0]);
  }
  return t;
}
const Pt = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g, $t = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
function oe(e, t) {
  const { font: n } = t, r = n ? n == null ? void 0 : n.preferredFormat : void 0;
  return r ? e.replace($t, (a) => {
    for (; ; ) {
      const [i, , o] = Pt.exec(a) || [];
      if (!o)
        return "";
      if (o === r)
        return `src: ${i};`;
    }
  }) : e;
}
function Bt(e, t) {
  if (F(e)) {
    const n = e.currentSrc || e.src;
    if (!j(n))
      return [
        B(t, {
          url: n,
          imageDom: e,
          requestType: "image",
          responseType: "dataUrl"
        }).then((r) => {
          r && (e.srcset = "", e.dataset.originalSrc = n, e.src = r || "");
        })
      ];
    ($ || me) && n.includes("data:image/svg+xml") && t.drawImageCount++;
  } else if (I(e) && !j(e.href.baseVal)) {
    const n = e.href.baseVal;
    return [
      B(t, {
        url: n,
        imageDom: e,
        requestType: "image",
        responseType: "dataUrl"
      }).then((r) => {
        r && (e.dataset.originalSrc = n, e.href.baseVal = r || "");
      })
    ];
  }
  return [];
}
const Lt = [
  "background-image",
  "border-image-source",
  "-webkit-border-image",
  "-webkit-mask-image",
  "list-style-image"
];
function Mt(e, t) {
  return Lt.map((n) => {
    const r = e.getPropertyValue(n);
    return r ? (($ || me) && r.includes("data:image/svg+xml") && t.drawImageCount++, Ne(r, null, t, !0).then((a) => {
      !a || r === a || e.setProperty(
        n,
        a,
        e.getPropertyPriority(n)
      );
    })) : null;
  }).filter(Boolean);
}
function ke(e, t) {
  const { tasks: n } = t;
  T(e) && (F(e) || he(e)) && n.push(...Bt(e, t)), z(e) && n.push(...Mt(e.style, t)), e.childNodes.forEach((r) => {
    ke(r, t);
  });
}
function Ot(e, t) {
  return b(this, null, function* () {
    const n = yield A(e, t);
    if (T(n.node) && I(n.node))
      return n.node;
    const {
      ownerDocument: r,
      log: a,
      tasks: i,
      svgStyleElement: o,
      svgDefsElement: c,
      svgStyles: s,
      font: l,
      progress: u,
      autoDestruct: f,
      onCloneNode: d,
      onEmbedNode: g,
      onCreateForeignObjectSvg: h
    } = n;
    a.time("clone node");
    const p = yield W(n.node, n, !0);
    if (o && r) {
      let C = "";
      s.forEach((k, D) => {
        C += `${k.join(`,
`)} {
  ${D}
}
`;
      }), o.appendChild(r.createTextNode(C));
    }
    a.timeEnd("clone node"), d == null || d(p), l !== !1 && T(p) && (a.time("embed web font"), yield Ft(p, n), a.timeEnd("embed web font")), a.time("embed node"), ke(p, n);
    const y = i.length;
    let m = 0;
    const S = () => b(this, null, function* () {
      for (; ; ) {
        const C = i.pop();
        if (!C)
          break;
        try {
          yield C;
        } catch (k) {
          E("Failed to run task", k);
        }
        u == null || u(++m, y);
      }
    });
    u == null || u(m, y), yield Promise.all([...Array(4)].map(S)), a.timeEnd("embed node"), g == null || g(p);
    const w = Wt(p, n);
    return c && w.insertBefore(c, w.children[0]), o && w.insertBefore(o, w.children[0]), f && It(n), h == null || h(w), w;
  });
}
function Wt(e, t) {
  const { width: n, height: r } = t, a = pe(n, r, e.ownerDocument), i = a.ownerDocument.createElementNS(a.namespaceURI, "foreignObject");
  return i.setAttributeNS(null, "x", "0%"), i.setAttributeNS(null, "y", "0%"), i.setAttributeNS(null, "width", "100%"), i.setAttributeNS(null, "height", "100%"), i.append(e), a.appendChild(i), a;
}
function X(e, t) {
  return b(this, null, function* () {
    var o;
    const n = yield A(e, t), r = yield Ot(n), a = ye(r);
    n.autoDestruct || (n.svgStyleElement = Ce(n.ownerDocument), n.svgDefsElement = (o = n.ownerDocument) == null ? void 0 : o.createElementNS(O, "defs"), n.svgStyles.clear());
    const i = x(a, r.ownerDocument);
    return yield gt(i, n);
  });
}
function Vt(e, t) {
  return b(this, null, function* () {
    const n = yield A(e, t), { log: r, type: a, quality: i, dpi: o } = n, c = yield X(n);
    r.time("canvas to blob");
    const s = yield ot(c, a, i);
    if (["image/png", "image/jpeg"].includes(a) && o) {
      const l = yield it(s.slice(0, 33));
      let u = new Uint8Array(l);
      return a === "image/png" ? u = fe(u, o) : a === "image/jpeg" && (u = se(u, o)), new Blob([u, s.slice(33)], { type: a });
    }
    return r.timeEnd("canvas to blob"), s;
  });
}
function U(e, t) {
  return b(this, null, function* () {
    const n = yield A(e, t), { log: r, quality: a, type: i, dpi: o } = n, c = yield X(n);
    r.time("canvas to data url");
    let s = c.toDataURL(i, a);
    if (["image/png", "image/jpeg"].includes(i) && o && de && We) {
      const [l, u] = s.split(",");
      let f = 0, d = !1;
      if (i === "image/png") {
        const w = Me(u);
        w >= 0 ? (f = Math.ceil((w + 28) / 3) * 4, d = !0) : f = 33 / 3 * 4;
      } else
        i === "image/jpeg" && (f = 18 / 3 * 4);
      const g = u.substring(0, f), h = u.substring(f), p = window.atob(g), y = new Uint8Array(p.length);
      for (let w = 0; w < y.length; w++)
        y[w] = p.charCodeAt(w);
      const m = i === "image/png" ? fe(y, o, d) : se(y, o), S = window.btoa(String.fromCharCode(...m));
      s = [l, ",", S, h].join("");
    }
    return r.timeEnd("canvas to data url"), s;
  });
}
function qt(e, t) {
  return b(this, null, function* () {
    const n = yield A(e, t), { width: r, height: a, ownerDocument: i } = n, o = yield U(n), c = pe(r, a, i), s = c.ownerDocument.createElementNS(c.namespaceURI, "image");
    return s.setAttributeNS(null, "href", o), s.setAttributeNS(null, "height", "100%"), s.setAttributeNS(null, "width", "100%"), c.appendChild(s), ye(c);
  });
}
function Ht(e, t) {
  return b(this, null, function* () {
    const n = yield A(e, t), { ownerDocument: r, width: a, height: i, scale: o, type: c } = n, s = c === "image/svg+xml" ? yield qt(n) : yield U(n), l = x(s, r);
    return l.width = Math.floor(a * o), l.height = Math.floor(i * o), l.style.width = `${a}px`, l.style.height = `${i}px`, l;
  });
}
function zt(e, t) {
  return b(this, null, function* () {
    return U(
      yield A(e, R(v({}, t), { type: "image/jpeg" }))
    );
  });
}
function Xt(e, t) {
  return b(this, null, function* () {
    const n = yield A(e, t), r = yield X(n);
    return r.getContext("2d").getImageData(0, 0, r.width, r.height).data;
  });
}
function Gt(e, t) {
  return b(this, null, function* () {
    return U(
      yield A(e, R(v({}, t), { type: "image/png" }))
    );
  });
}
function Yt(e, t) {
  return b(this, null, function* () {
    return U(
      yield A(e, R(v({}, t), { type: "image/webp" }))
    );
  });
}
export {
  ft as createContext,
  It as destroyContext,
  Vt as domToBlob,
  X as domToCanvas,
  U as domToDataUrl,
  Ot as domToForeignObjectSvg,
  Ht as domToImage,
  zt as domToJpeg,
  Xt as domToPixel,
  Gt as domToPng,
  qt as domToSvg,
  Yt as domToWebp,
  _ as loadMedia,
  ct as waitUntilLoad
};
